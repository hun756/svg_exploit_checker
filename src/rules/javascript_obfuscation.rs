use super::ExploitRule;
use crate::svg_checker::SvgCheckError;
use async_trait::async_trait;
use quick_xml::events::Event;
use quick_xml::name::QName;
use quick_xml::Reader;
use regex::RegexSet;
use std::collections::HashSet;

pub struct JavaScriptObfuscationRule {
    suspicious_patterns: RegexSet,
    suspicious_functions: HashSet<&'static str>,
}

impl JavaScriptObfuscationRule {
    pub fn new() -> Self {
        let suspicious_patterns = RegexSet::new(&[
            r"\\x[0-9a-fA-F]{2}",
            r"\\u[0-9a-fA-F]{4}",
            r"\\[0-7]{1,3}",
            r"(?i)eval\s*\(|new\s+Function|setTimeout|setInterval",
            r"atob\s*\(|btoa\s*\(",
            r"String\.fromCharCode|unescape|decodeURIComponent",
            r#"\['[a-zA-Z_$][0-9a-zA-Z_$]*'\]|\[\"[a-zA-Z_$][0-9a-zA-Z_$]*\"\]"#,
            r#"'[\da-fA-F]+'|\"[\da-fA-F]+\""#,
            r"(?i)_0x[a-f0-9]{4,}",
            r"(?i)window\[|document\[|self\[|this\[",
            r"\(\s*\+\s*\+\s*\[\s*\]\s*\+\s*\[\s*\]\s*\)",
            r"\(!\+\[\]\+\[\]\)",
            r"\.split\s*\(\s*''\s*\)\.reverse\(\)\.join\s*\(\s*''\s*\)",
            r"\\[1-7][0-7]{0,2}|\\x[0-9A-Fa-f]{2}|\\u[0-9A-Fa-f]{4}",
            r"with\s*\(",
        ])
        .unwrap();

        let suspicious_functions: HashSet<&'static str> = [
            "eval",
            "Function",
            "setTimeout",
            "setInterval",
            "execScript",
            "crypto.generateCRMFRequest",
            "ScriptElement.setAttribute",
            "document.write",
            "window.execScript",
            "generateFromEncryptedSeed",
            "document.createElement",
            "document.body.appendChild",
            "String.fromCharCode",
            "unescape",
            "decodeURIComponent",
            "encodeURIComponent",
            "escape",
            "atob",
            "btoa",
        ]
        .iter()
        .copied()
        .collect();

        JavaScriptObfuscationRule {
            suspicious_patterns,
            suspicious_functions,
        }
    }

    fn check_content(&self, content: &str) -> Option<String> {
        if self
            .suspicious_patterns
            .matches(content)
            .into_iter()
            .next()
            .is_some()
        {
            return Some("Suspicious pattern detected".to_string());
        }

        if self.calculate_entropy(content) > 5.7 {
            return Some("High entropy detected, possible encoded payload".to_string());
        }

        if content
            .split_whitespace()
            .any(|word| self.suspicious_functions.contains(word))
        {
            return Some("Suspicious function call detected".to_string());
        }

        if self.check_excessive_concatenation(content) {
            return Some("Excessive string concatenation detected".to_string());
        }

        None
    }

    fn calculate_entropy(&self, s: &str) -> f64 {
        let mut char_counts = [0u32; 256];
        let total_chars = s.len() as f64;

        for &b in s.as_bytes() {
            char_counts[b as usize] += 1;
        }

        -char_counts
            .iter()
            .filter(|&&count| count > 0)
            .fold(0.0, |acc, &count| {
                let p = count as f64 / total_chars;
                acc + p * p.log2()
            })
    }

    fn check_excessive_concatenation(&self, content: &str) -> bool {
        content.bytes().filter(|&b| b == b'+' || b == b'=').count() > 20
    }
}

#[async_trait]
impl ExploitRule for JavaScriptObfuscationRule {
    async fn check_event(
        &self,
        e: &quick_xml::events::BytesStart<'_>,
        reader: &Reader<&[u8]>,
    ) -> Result<(), SvgCheckError> {
        for attr in e.attributes().filter_map(|a| a.ok()) {
            if let Ok(value) = std::str::from_utf8(&attr.value) {
                if let Some(reason) = self.check_content(value) {
                    return Err(SvgCheckError::ExploitDetected(format!(
                        "Potential obfuscated JavaScript in attribute: {}",
                        reason
                    )));
                }
            }
        }

        if e.name() == QName(b"script") {
            let mut reader = reader.clone();
            let mut script_content = String::new();

            loop {
                match reader.read_event() {
                    Ok(Event::Text(text)) => {
                        script_content.push_str(&text.unescape().unwrap_or_default());
                    }
                    Ok(Event::End(end)) if end.name() == QName(b"script") => break,
                    Ok(Event::Eof) => break,
                    Err(e) => return Err(SvgCheckError::ParseError(e)),
                    _ => (),
                }
            }

            if let Some(reason) = self.check_content(&script_content) {
                return Err(SvgCheckError::ExploitDetected(format!(
                    "Potential obfuscated JavaScript in <script> tag: {}",
                    reason
                )));
            }
        }

        Ok(())
    }
}
