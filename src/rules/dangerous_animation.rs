use super::ExploitRule;
use crate::svg_checker::SvgCheckError;
use async_trait::async_trait;
use lazy_static::lazy_static;
use quick_xml::events::BytesStart;
use quick_xml::name::QName;
use quick_xml::Reader;
use regex::Regex;
use std::collections::HashSet;

pub struct DangerousAnimationRule {
    dangerous_attributes: HashSet<String>,
    suspicious_values: Regex,
}

impl DangerousAnimationRule {
    pub fn new() -> Self {
        let mut dangerous_attributes = HashSet::new();
        dangerous_attributes.extend(
            vec![
                "href",
                "xlink:href",
                "onload",
                "onerror",
                "style",
                "from",
                "to",
                "values",
                "by",
                "attributeName",
                "begin",
                "end",
                "dur",
                "repeatCount",
                "fill",
            ]
            .into_iter()
            .map(String::from),
        );

        lazy_static! {
            static ref SUSPICIOUS_VALUES: Regex = Regex::new(
                r"(?i)(javascript|data|vbscript):|alert\s*\(|eval\s*\(|settimeout\s*\(|setinterval\s*\(|&\{|document\.|window\.|\.cookie|<script|<iframe|<object|<embed"
            ).unwrap();
        }

        DangerousAnimationRule {
            dangerous_attributes,
            suspicious_values: SUSPICIOUS_VALUES.clone(),
        }
    }

    fn is_dangerous_animation(&self, e: &BytesStart) -> bool {
        matches!(
            e.name(),
            QName(b"animate")
                | QName(b"set")
                | QName(b"animateTransform")
                | QName(b"animateMotion")
        )
    }

    fn check_attribute(&self, attr_key: &str, attr_value: &str) -> Result<(), SvgCheckError> {
        if self.dangerous_attributes.contains(attr_key) {
            if self.suspicious_values.is_match(attr_value) {
                return Err(SvgCheckError::ExploitDetected(format!(
                    "Suspicious value '{}' found in '{}' attribute",
                    attr_value, attr_key
                )));
            }
        }

        if attr_key == "attributeName" && self.dangerous_attributes.contains(attr_value) {
            return Err(SvgCheckError::ExploitDetected(format!(
                "Dangerous animation targeting '{}' found",
                attr_value
            )));
        }

        Ok(())
    }
}

#[async_trait]
impl ExploitRule for DangerousAnimationRule {
    async fn check_event(
        &self,
        e: &BytesStart<'_>,
        _reader: &Reader<&[u8]>,
    ) -> Result<(), SvgCheckError> {
        if self.is_dangerous_animation(e) {
            for attr in e.attributes().filter_map(Result::ok) {
                let attr_key = attr.key.local_name();
                let attr_key_str = std::str::from_utf8(attr_key.as_ref()).map_err(|_| {
                    SvgCheckError::ExploitDetected("Invalid UTF-8 in attribute key".to_string())
                })?;
                let attr_value = std::str::from_utf8(&attr.value).map_err(|_| {
                    SvgCheckError::ExploitDetected("Invalid UTF-8 in attribute value".to_string())
                })?;

                self.check_attribute(attr_key_str, attr_value)?;
            }
        }

        Ok(())
    }
}
