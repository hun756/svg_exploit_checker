use async_trait::async_trait;
use quick_xml::Reader;
use quick_xml::name::QName;
use crate::svg_checker::SvgCheckError;
use super::ExploitRule;

pub struct DangerousAnimationRule;

impl DangerousAnimationRule {
    pub fn new() -> Self {
        DangerousAnimationRule
    }
}

#[async_trait]
impl ExploitRule for DangerousAnimationRule {
    async fn check_event(&self, e: &quick_xml::events::BytesStart<'_>, _reader: &Reader<&[u8]>) -> Result<(), SvgCheckError> {
        if e.name() == QName(b"animate") || e.name() == QName(b"set") {
            for attr in e.attributes().filter_map(|a| a.ok()) {
                let local_name = attr.key.local_name();
                let attr_key = local_name.as_ref();
                let attr_key_str = std::str::from_utf8(attr_key).unwrap_or("");
                let attr_value = std::str::from_utf8(&attr.value).unwrap_or("");
                if attr_key_str == "attributeName" {
                    match attr_value {
                        "href" | "xlink:href" | "onload" | "onerror" | "style" => {
                            return Err(SvgCheckError::ExploitDetected(format!("Dangerous animation targeting '{}' found", attr_value)));
                        }
                        _ => (),
                    }
                }
            }
        }

        Ok(())
    }
}
