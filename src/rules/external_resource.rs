use super::ExploitRule;
use crate::svg_checker::SvgCheckError;
use async_trait::async_trait;
use quick_xml::events::Event;
use quick_xml::Reader;

pub struct ExternalResourceRule;

impl ExternalResourceRule {
    pub fn new() -> Self {
        ExternalResourceRule
    }

    fn check_tag(&self, e: &quick_xml::events::BytesStart<'_>) -> Result<(), SvgCheckError> {
        let tags_with_external_resources: Vec<&[u8]> = vec![b"image", b"use", b"script", b"link"];

        let name_bytes = e.name().into_inner();

        if tags_with_external_resources.contains(&name_bytes) {
            for attr in e.attributes().filter_map(|a| a.ok()) {
                if let Ok(val) = std::str::from_utf8(&attr.value) {
                    if val.starts_with("http://") || val.starts_with("https://") {
                        let tag_name = std::str::from_utf8(name_bytes).unwrap_or("");
                        return Err(SvgCheckError::ExploitDetected(format!(
                            "External resource found in tag {}: {}",
                            tag_name, val
                        )));
                    }
                }
            }
        }
        Ok(())
    }
}

#[async_trait]
impl ExploitRule for ExternalResourceRule {
    async fn check_event(
        &self,
        _e: &quick_xml::events::BytesStart<'_>,
        reader: &Reader<&[u8]>,
    ) -> Result<(), SvgCheckError> {
        let mut reader = reader.clone();
        loop {
            match reader.read_event() {
                Ok(Event::Start(ref e)) => {
                    if let Err(err) = self.check_tag(e) {
                        return Err(err);
                    }
                }
                Ok(Event::Empty(ref e)) => {
                    if let Err(err) = self.check_tag(e) {
                        return Err(err);
                    }
                }
                Ok(Event::Eof) => break,
                Err(e) => return Err(SvgCheckError::ParseError(e)),
                _ => (),
            }
        }
        Ok(())
    }
}
