use async_trait::async_trait;
use quick_xml::Reader;
use quick_xml::name::QName;
use crate::svg_checker::SvgCheckError;
use super::ExploitRule;

pub struct MaliciousLinkRule;

impl MaliciousLinkRule {
    pub fn new() -> Self {
        MaliciousLinkRule
    }
}

#[async_trait]
impl ExploitRule for MaliciousLinkRule {
    async fn check_event(&self, e: &quick_xml::events::BytesStart<'_>, _reader: &Reader<&[u8]>) -> Result<(), SvgCheckError> {
        if e.name() == QName(b"a") {
            for attr in e.attributes().filter_map(|a| a.ok()) {
                let local_name = attr.key.local_name();
                let attr_key = local_name.as_ref();
                let attr_key_str = std::str::from_utf8(attr_key).unwrap_or("");
                if attr_key_str == "href" {
                    let value = std::str::from_utf8(&attr.value).unwrap_or("");
                    if value.starts_with("http") && (value.contains("javascript:") || value.contains("//:")) {
                        return Err(SvgCheckError::ExploitDetected(format!("Potentially malicious link detected: {}", value)));
                    }
                }
            }
        }
        Ok(())
    }
}