use async_trait::async_trait;
use std::path::PathBuf;
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};
use quick_xml::Reader;
use quick_xml::events::Event;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum SvgCheckError {
    #[error("error reading file")]
    IOError(#[from] io::Error),
    #[error("error parsing XML")]
    ParseError(#[from] quick_xml::Error),
    #[error("detected potential exploit")]
    ExploitDetected(String),
}

pub struct SvgChecker {
    rules: Vec<Box<dyn ExploitRule + Send + Sync>>,
}

impl SvgChecker {
    pub fn new() -> Self {
        SvgChecker {
            rules: vec![
                Box::new(ScriptTagRule {}),
                // Additional rules can be added here
            ],
        }
    }

    pub async fn check_file(&self, path: PathBuf) -> Result<(), SvgCheckError> {
        let mut file = File::open(path).await?;
        let mut contents = Vec::new();
        file.read_to_end(&mut contents).await?;
        self.check(&contents).await
    }

    async fn check(&self, data: &[u8]) -> Result<(), SvgCheckError> {
        let mut reader = Reader::from_reader(data);
        loop {
            match reader.read_event() {
                Ok(Event::Start(ref e)) => {
                    for rule in &self.rules {
                        rule.check_event(e, &reader).await?;
                    }
                },
                Ok(Event::Eof) => break,
                Err(e) => return Err(SvgCheckError::ParseError(e)),
                _ => (),
            }
        }
        Ok(())
    }
}

#[async_trait]
pub trait ExploitRule {
    async fn check_event(&self, e: &quick_xml::events::BytesStart<'_>, reader: &Reader<&[u8]>) -> Result<(), SvgCheckError>;
}

struct ScriptTagRule;

#[async_trait]
impl ExploitRule for ScriptTagRule {
    async fn check_event(&self, e: &quick_xml::events::BytesStart<'_>, _reader: &Reader<&[u8]>) -> Result<(), SvgCheckError> {
        if e.name() == quick_xml::name::QName(b"script") {
            Err(SvgCheckError::ExploitDetected("Script tag found".to_string()))
        } else {
            Ok(())
        }
    }
}

#[tokio::main]
async fn main() -> Result<(), SvgCheckError> {
    let checker = SvgChecker::new();
    match checker.check_file(PathBuf::from("exploit_test.svg")).await {
        Ok(_) => println!("No exploit detected"),
        Err(SvgCheckError::ExploitDetected(msg)) => println!("Exploit detected: {}", msg),
        Err(e) => println!("Error: {}", e),
    }
    Ok(())
}