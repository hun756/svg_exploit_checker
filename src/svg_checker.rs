use std::path::PathBuf;
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};
use quick_xml::Reader;
use quick_xml::events::Event;
use thiserror::Error;

use crate::rules::ExploitRule;

#[derive(Error, Debug)]
pub enum SvgCheckError {
    #[error("error reading file")]
    IOError(#[from] io::Error),
    #[error("error parsing XML")]
    ParseError(#[from] quick_xml::Error),
    #[error("detected potential exploit")]
    ExploitDetected(String),
}

pub struct SvgChecker {
    rules: Vec<Box<dyn ExploitRule + Send + Sync>>,
}

impl SvgChecker {
    pub fn new() -> Self {
        use crate::rules::*;
        SvgChecker {
            rules: vec![
                Box::new(ScriptTagRule::new()),
                // Add more rules here
            ],
        }
    }

    pub async fn check_file(&self, path: PathBuf) -> Result<(), SvgCheckError> {
        let mut file = File::open(path).await?;
        let mut contents = Vec::new();
        file.read_to_end(&mut contents).await?;
        self.check(&contents).await
    }

    async fn check(&self, data: &[u8]) -> Result<(), SvgCheckError> {
        let mut reader = Reader::from_reader(data);
        loop {
            match reader.read_event() {
                Ok(Event::Start(ref e)) => {
                    for rule in &self.rules {
                        rule.check_event(e, &reader).await?;
                    }
                },
                Ok(Event::Eof) => break,
                Err(e) => return Err(SvgCheckError::ParseError(e)),
                _ => (),
            }
        }
        Ok(())
    }
}