use anyhow::Result;
use quick_xml::events::Event;
use quick_xml::Reader;
use serde::Deserialize;
use std::path::Path;
use thiserror::Error;
use tokio::fs::File;
use tokio::io::{self, AsyncReadExt};

use crate::rules::ExploitRule;

#[derive(Error, Debug)]
pub enum SvgCheckError {
    #[error("error reading file")]
    IOError(#[from] io::Error),
    #[error("error parsing XML")]
    ParseError(#[from] quick_xml::Error),
    #[error("detected potential exploit")]
    ExploitDetected(String),
}

#[derive(Deserialize)]
pub struct Config {
    pub rules: Vec<String>,
    // Add more configuration options as needed
}

impl Config {
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let config: Config = toml::from_str(&content)?;
        Ok(config)
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            rules: vec!["ScriptTagRule".to_string()],
        }
    }
}

pub struct SvgChecker {
    rules: Vec<Box<dyn ExploitRule + Send + Sync>>,
}

impl SvgChecker {
    pub fn new(config: Config) -> Self {
        use crate::rules::*;
        let mut rules: Vec<Box<dyn ExploitRule + Send + Sync>> = Vec::new();
        for rule in config.rules {
            match rule.as_str() {
                "ScriptTagRule" => rules.push(Box::new(ScriptTagRule::new())),
                "ExternalResourceRule" => rules.push(Box::new(ExternalResourceRule::new())),
                "InlineEventHandlerRule" => rules.push(Box::new(InlineEventHandlerRule::new())),
                "ForeignObjectRule" => rules.push(Box::new(ForeignObjectRule::new())),
                "CssInjectionRule" => rules.push(Box::new(CssInjectionRule::new())),
                "DangerousAnimationRule" => rules.push(Box::new(DangerousAnimationRule::new())),
                "Base64EmbeddingRule" => rules.push(Box::new(Base64EmbeddingRule::new())),
                "MaliciousLinkRule" => rules.push(Box::new(MaliciousLinkRule::new())),
                "IdReuseRule" => rules.push(Box::new(IdReuseRule::new())),
                _ => println!("Warning: Unknown rule '{}'", rule),
            }
        }
        SvgChecker { rules }
    }

    pub async fn check_file<P: AsRef<Path>>(&self, path: P) -> Result<(), SvgCheckError> {
        let mut file = File::open(path).await?;
        let mut contents = Vec::new();
        file.read_to_end(&mut contents).await?;
        self.check(&contents).await
    }

    async fn check(&self, data: &[u8]) -> Result<(), SvgCheckError> {
        let mut reader = Reader::from_reader(data);
        loop {
            match reader.read_event() {
                Ok(Event::Start(ref e)) | Ok(Event::Empty(ref e)) => {
                    for rule in &self.rules {
                        if let Err(err) = rule.check_event(e, &reader).await {
                            eprintln!("Error detected: {:?}", err);
                            return Err(err);
                        }
                    }
                },
                Ok(Event::Eof) => break,
                Err(e) => return Err(SvgCheckError::ParseError(e)),
                _ => (),
            }
        }
        Ok(())
    }
}
